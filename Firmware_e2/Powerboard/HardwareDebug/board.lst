   1                             		.file	"board.c"
   2                             		.section P,"ax"
   3                             	.Ltext0:
   4                             		.comm	_ms_counter,4,4
   5                             		.comm	_ms_counter2,4,4
   6                             		.comm	_delay_counter,4,4
   7                             		.section	.text.init_clock,"ax",@progbits
   8                             		.global	_init_clock
  10                             	_init_clock:
  11                             	.LFB0:
  12                             		.file 1 "../src/board.c"
   1:../src/board.c **** /*
   2:../src/board.c ****  * board.c
   3:../src/board.c ****  *
   4:../src/board.c ****  *  Created on: 31.10.2018
   5:../src/board.c ****  *      Author: Besitzer
   6:../src/board.c ****  */
   7:../src/board.c **** 
   8:../src/board.c **** 
   9:../src/board.c **** /************************************************************************
  10:../src/board.c ****  * Includes
  11:../src/board.c ****  ***********************************************************************/
  12:../src/board.c **** #include "board.h"
  13:../src/board.c **** #include "gpio.h"
  14:../src/board.c **** 
  15:../src/board.c **** /************************************************************************
  16:../src/board.c ****  * Informations
  17:../src/board.c ****  ***********************************************************************/
  18:../src/board.c **** 
  19:../src/board.c **** /************************************************************************
  20:../src/board.c ****  * Global Variable
  21:../src/board.c ****  ***********************************************************************/
  22:../src/board.c **** /* Uhr    */
  23:../src/board.c **** unsigned long int ms_counter,ms_counter2, delay_counter;
  24:../src/board.c **** /* Declare the simulated EEPROM data table */
  25:../src/board.c **** /************************************************************************
  26:../src/board.c ****  * Local Variable
  27:../src/board.c ****  ***********************************************************************/
  28:../src/board.c **** 
  29:../src/board.c **** /************************************************************************
  30:../src/board.c ****  * Constant
  31:../src/board.c ****  ***********************************************************************/
  32:../src/board.c **** 
  33:../src/board.c **** /************************************************************************
  34:../src/board.c ****  * Local Funtions
  35:../src/board.c ****  ***********************************************************************/
  36:../src/board.c **** 
  37:../src/board.c **** /************************************************************************
  38:../src/board.c **** *! \fn			init_clock( void )
  39:../src/board.c **** *  \brief		cpu clock initialization
  40:../src/board.c **** *  \param		none
  41:../src/board.c **** *  \exception	none
  42:../src/board.c **** *  \return		none
  43:../src/board.c **** ************************************************************************/
  44:../src/board.c **** void init_clock( void ){
  13                             		.loc 1 44 0
  14 0000 7E A6                   		push.l	r6
  15                             	.LCFI0:
  16 0002 71 06 FC                		add	#-4, r0, r6
  17                             	.LCFI1:
  18 0005 EF 60                   		mov.L	r6, r0
  19                             	.LCFI2:
  45:../src/board.c **** 
  46:../src/board.c **** 	/*
  47:../src/board.c ****     Clock Description              Frequency
  48:../src/board.c **** 	----------------------------------------
  49:../src/board.c **** 	Input Clock Frequency............  12 MHz
  50:../src/board.c **** 	PLL frequency (x16).............. 192 MHz
  51:../src/board.c **** 	Internal Clock Frequency.........  96 MHz
  52:../src/board.c **** 	Peripheral Clock Frequency.......  48 MHz
  53:../src/board.c **** 	USB Clock Frequency..............  48 MHz
  54:../src/board.c **** 	External Bus Clock Frequency.....  24 MHz */
  55:../src/board.c **** 
  56:../src/board.c **** 	volatile unsigned int i;
  57:../src/board.c **** 
  58:../src/board.c **** 	SYSTEM.PRCR.WORD = 0xA50B;			// Protect off.
  20                             		.loc 1 58 0
  21 0007 FB 5E 00 00 08          		mov.L	#0x80000, r5
  22 000c FA 59 FF 01 0B A5       		mov.W	#0xffffa50b, 1022[r5]
  59:../src/board.c **** 	//SYSTEM.SOSCCR.BYTE = 0x01;        // stop sub-clock // Uncomment if not using sub-clock
  60:../src/board.c **** 	SYSTEM.SOSCCR.BYTE = 0x00;			// Enable sub-clock for RTC
  23                             		.loc 1 60 0
  24 0012 FB 5E 00 00 08          		mov.L	#0x80000, r5
  25 0017 F9 54 33 00             		mov.B	#0, 51[r5]
  61:../src/board.c **** 	SYSTEM.MOSCWTCR.BYTE = 0x0D;		// Wait 131,072 cycles * 12 MHz = 10.9 ms
  26                             		.loc 1 61 0
  27 001b FB 5E 00 00 08          		mov.L	#0x80000, r5
  28 0020 F9 54 A2 0D             		mov.B	#13, 162[r5]
  62:../src/board.c **** 	SYSTEM.PLLWTCR.BYTE = 0x04;			// PLL wait is 4,194,304 cycles (default) * 192 MHz (12 MHz * 16) = 
  29                             		.loc 1 62 0
  30 0024 FB 5E 00 00 08          		mov.L	#0x80000, r5
  31 0029 F9 54 A6 04             		mov.B	#4, 166[r5]
  63:../src/board.c **** 	SYSTEM.PLLCR.WORD = 0x0F00;			// x16 @PLL */
  32                             		.loc 1 63 0
  33 002d FB 5E 00 00 08          		mov.L	#0x80000, r5
  34 0032 F9 59 14 00 0F          		mov.W	#0xf00, 40[r5]
  64:../src/board.c **** 	SYSTEM.MOSCCR.BYTE = 0x00;			// EXTAL ON
  35                             		.loc 1 64 0
  36 0037 FB 5E 00 00 08          		mov.L	#0x80000, r5
  37 003c F9 54 32 00             		mov.B	#0, 50[r5]
  65:../src/board.c **** 	SYSTEM.PLLCR2.BYTE = 0x00;			// PLL ON
  38                             		.loc 1 65 0
  39 0040 FB 5E 00 00 08          		mov.L	#0x80000, r5
  40 0045 F9 54 2A 00             		mov.B	#0, 42[r5]
  66:../src/board.c ****     for(i = 0;i< 0x168;i++){
  41                             		.loc 1 66 0
  42 0049 F8 66 00                		mov.L	#0, [r6]
  43 004c 08                      		bra	.L2
  44                             	.L3:
  67:../src/board.c ****     	asm("nop");        					// Wait over 12ms
  45                             		.loc 1 67 0 discriminator 2
  46                             	 ; 67 "../src/board.c" 1
  47 004d 03                      		nop
  48                             	 ; 0 "" 2
  66:../src/board.c ****     for(i = 0;i< 0x168;i++){
  49                             		.loc 1 66 0 discriminator 2
  50 004e EC 65                   		mov.L	[r6], r5
  51 0050 62 15                   		add	#1, r5
  52 0052 E3 65                   		mov.L	r5, [r6]
  53                             	.L2:
  66:../src/board.c ****     for(i = 0;i< 0x168;i++){
  54                             		.loc 1 66 0 is_stmt 0 discriminator 1
  55 0054 EC 65                   		mov.L	[r6], r5
  56 0056 76 05 67 01             		cmp	#0x167, r5
  57 005a 25 F3                   		bleu	.L3
  68:../src/board.c **** 	}
  69:../src/board.c **** 
  70:../src/board.c **** 	/* Setup system clocks
  71:../src/board.c **** 	SCKCR - System Clock Control Register
  72:../src/board.c **** 	b31:b28 FCK[3:0]  0x02 = Flash clock: PLL/4 = (192 / 4) = 48 MHz
  73:../src/board.c **** 	b27:b24 ICK[3:0]  0x01 = System clock: PLL/2 = (192 / 2) = 96 MHz
  74:../src/board.c **** 	b23     PSTOP1    0x00 = BCLK pin output is enabled
  75:../src/board.c **** 	b19:b16 BCK[3:0]  0x03 = BCLK: PLL/8 = 24 MHz
  76:../src/board.c **** 	b11:b8  PCKB[3:0] 0x02 = Peripheral clock B: PLL/4 = 48 MHz
  77:../src/board.c **** 	*/
  78:../src/board.c **** 
  79:../src/board.c **** 	//	SYSTEM.SCKCR.LONG = 0x22862211;		//Mre 0x21031222;// ICK=PLL/4,BCK,FCK,PCK=PLL/4
  80:../src/board.c **** 	SYSTEM.SCKCR.LONG = 0x21862211;		//Mre 0x21031222;// ICK=PLL/2,BCK,FCK,PCK=PLL/4
  58                             		.loc 1 80 0 is_stmt 1
  59 005c FB 5E 00 00 08          		mov.L	#0x80000, r5
  60 0061 F9 52 08 11 22 86 21    		mov.L	#0x21862211, 32[r5]
  81:../src/board.c **** 
  82:../src/board.c **** 	/* Setup IEBUS and USB clocks
  83:../src/board.c **** 	SCKCR2 - System Clock Control Register 2
  84:../src/board.c **** 	b7:b4 UCK[3:0]   0x03 = USB clock is PLL/4 = 48 MHz
  85:../src/board.c **** 	b3:b0 IEBCK[3:0] 0x01 = IE Bus clock is PLL/2 = 96 MHz
  86:../src/board.c **** 	*/
  87:../src/board.c **** 
  88:../src/board.c **** 	SYSTEM.SCKCR2.WORD = 0x00;//Mre 0x0031;
  61                             		.loc 1 88 0
  62 0068 FB 5E 00 00 08          		mov.L	#0x80000, r5
  63 006d 3D D2 00                		mov.W	#0, 36[r5]
  89:../src/board.c **** 	SYSTEM.SCKCR3.WORD = 0x0400;				// ICLK, PCLKB, FCLK, BCLK, IECLK, and USBCLK all come from PLL ci
  64                             		.loc 1 89 0
  65 0070 FB 5E 00 00 08          		mov.L	#0x80000, r5
  66 0075 F9 59 13 00 04          		mov.W	#0x400, 38[r5]
  90:../src/board.c **** 	SYSTEM.PRCR.WORD = 0xA500;					// Protect on.
  67                             		.loc 1 90 0
  68 007a FB 5E 00 00 08          		mov.L	#0x80000, r5
  69 007f FA 59 FF 01 00 A5       		mov.W	#0xffffa500, 1022[r5]
  91:../src/board.c **** 
  92:../src/board.c **** }
  70                             		.loc 1 92 0
  71 0085 3F 66 02                		rtsd	#8, r6-r6
  72                             	.LFE0:
  74                             		.section	.text.Timer_MTU3_init,"ax",@progbits
  75                             		.global	_Timer_MTU3_init
  77                             	_Timer_MTU3_init:
  78                             	.LFB1:
  93:../src/board.c **** 
  94:../src/board.c **** /************************************************************************
  95:../src/board.c **** *! \fn			Timer_MTU3_init(void)
  96:../src/board.c **** *  \brief		Function configures the MTU2a's channel 3 using compare match method
  97:../src/board.c **** *				  to generate a interrupt function to set the time for the Output.
  98:../src/board.c **** *  \param		none
  99:../src/board.c **** *  \exception	none
 100:../src/board.c **** *  \return		none
 101:../src/board.c **** ************************************************************************/
 102:../src/board.c **** void Timer_MTU3_init(void){
  79                             		.loc 1 102 0
  80 0000 7E A6                   		push.l	r6
  81                             	.LCFI3:
  82 0002 EF 06                   		mov.L	r0, r6
  83                             	.LCFI4:
 103:../src/board.c ****     SYSTEM.PRCR.WORD 	= 0xA503;		// Protection off
  84                             		.loc 1 103 0
  85 0004 FB 5E 00 00 08          		mov.L	#0x80000, r5
  86 0009 FA 59 FF 01 03 A5       		mov.W	#0xffffa503, 1022[r5]
 104:../src/board.c **** 	MSTP_MTU3 			= 0;			// Cancel the MTU0 module clock stop mode
  87                             		.loc 1 104 0
  88 000f FB 5E 00 00 08          		mov.L	#0x80000, r5
  89 0014 A9 54                   		mov.L	16[r5], r4
  90 0016 76 24 FF FD             		and	#0xfffffdff, r4
  91 001a A1 54                   		mov.L	r4, 16[r5]
 105:../src/board.c **** 	SYSTEM.PRCR.WORD 	= 0xA500;		// Protection on
  92                             		.loc 1 105 0
  93 001c FB 5E 00 00 08          		mov.L	#0x80000, r5
  94 0021 FA 59 FF 01 00 A5       		mov.W	#0xffffa500, 1022[r5]
 106:../src/board.c **** 
 107:../src/board.c **** 	MTU3.TCR.BYTE 		= 0x4D;			// Clock PCLK/1024, count at falling edge, TCNT cleared by TRGB compare 
  95                             		.loc 1 107 0
  96 0027 FB 5E 00 86 08          		mov.L	#0x88600, r5
  97 002c F8 54 4D                		mov.B	#0x4d, [r5]
 108:../src/board.c **** 	MTU3.TMDR.BYTE 		= 0;			// Operate timers in normal mode
  98                             		.loc 1 108 0
  99 002f FB 5E 00 86 08          		mov.L	#0x88600, r5
 100 0034 3C 52 00                		mov.B	#0, 2[r5]
 109:../src/board.c **** 	MTU3.TIORH.BYTE 	= 0x00;			// Initial output is 0
 101                             		.loc 1 109 0
 102 0037 FB 5E 00 86 08          		mov.L	#0x88600, r5
 103 003c 3C 54 00                		mov.B	#0, 4[r5]
 110:../src/board.c **** 	MTU.TRWER.BIT.RWE 	= 0x1;			// Enable access to protected MTU registers
 104                             		.loc 1 110 0
 105 003f FB 5E 0A 86 08          		mov.L	#0x8860a, r5
 106 0044 CD 54 7A                		mov.B	122[r5], r4
 107 0047 65 14                   		or	#1, r4
 108 0049 C7 54 7A                		mov.B	r4, 122[r5]
 111:../src/board.c **** 
 112:../src/board.c **** 	MTU3.TGRB	=0x28;
 109                             		.loc 1 112 0
 110 004c FB 5E 00 86 08          		mov.L	#0x88600, r5
 111 0051 3D 5D 28                		mov.W	#40, 26[r5]
 113:../src/board.c **** 
 114:../src/board.c **** 	IPR(MTU3,TGIB3) = 0x5;				// Set MTU3,TGIB3 interrupt priority level to 5
 112                             		.loc 1 114 0
 113 0054 FB 5E 00 70 08          		mov.L	#0x87000, r5
 114 0059 CE 54 98 03             		mov.B	920[r5], r4
 115 005d 75 24 F0                		and	#-16, r4
 116 0060 65 54                   		or	#5, r4
 117 0062 CB 54 98 03             		mov.B	r4, 920[r5]
 115:../src/board.c **** 	IEN(MTU3,TGIB3) = 0x1;				// Enable MTU3,TGIB3 interrupts
 118                             		.loc 1 115 0
 119 0066 FB 5E 00 70 08          		mov.L	#0x87000, r5
 120 006b CE 54 13 02             		mov.B	531[r5], r4
 121 006f 65 24                   		or	#2, r4
 122 0071 CB 54 13 02             		mov.B	r4, 531[r5]
 116:../src/board.c **** 	IR(MTU3,TGIB3) = 0x0;				// Clear MTU3,TGIB3 interrupt flag
 123                             		.loc 1 116 0
 124 0075 FB 5E 00 70 08          		mov.L	#0x87000, r5
 125 007a CD 54 99                		mov.B	153[r5], r4
 126 007d 75 24 FE                		and	#-2, r4
 127 0080 C7 54 99                		mov.B	r4, 153[r5]
 117:../src/board.c ****    	MTU3.TIER.BYTE = 0x02;    			// Enable TGIEA interrupts
 128                             		.loc 1 117 0
 129 0083 FB 5E 00 86 08          		mov.L	#0x88600, r5
 130 0088 3C 58 02                		mov.B	#2, 8[r5]
 118:../src/board.c **** 	MTU.TSTR.BIT.CST3 	= 0x1;			// Start MTU3 TCNT counter
 131                             		.loc 1 118 0
 132 008b FB 5E 0A 86 08          		mov.L	#0x8860a, r5
 133 0090 CD 54 76                		mov.B	118[r5], r4
 134 0093 75 34 40                		or	#64, r4
 135 0096 C7 54 76                		mov.B	r4, 118[r5]
 119:../src/board.c **** }
 136                             		.loc 1 119 0
 137 0099 3F 66 01                		rtsd	#4, r6-r6
 138                             	.LFE1:
 140                             		.section	.text.init_board,"ax",@progbits
 141                             		.global	_init_board
 143                             	_init_board:
 144                             	.LFB2:
 120:../src/board.c **** 
 121:../src/board.c **** /************************************************************************
 122:../src/board.c ****  * Global Funtions
 123:../src/board.c ****  ***********************************************************************/
 124:../src/board.c **** 
 125:../src/board.c **** /************************************************************************
 126:../src/board.c **** *! \fn			void init_board( void )
 127:../src/board.c **** *  \brief		initialization from cpu and peripheral
 128:../src/board.c **** *  \param		none
 129:../src/board.c **** *  \exception	none
 130:../src/board.c **** *  \return		none
 131:../src/board.c **** ************************************************************************/
 132:../src/board.c **** void init_board( void ){
 145                             		.loc 1 132 0
 146 0000 7E A6                   		push.l	r6
 147                             	.LCFI5:
 148 0002 EF 06                   		mov.L	r0, r6
 149                             	.LCFI6:
 133:../src/board.c **** 
 134:../src/board.c **** 	init_clock();
 150                             		.loc 1 134 0
 151 0004 05 00 00 00             		bsr	_init_clock
 135:../src/board.c **** 	Timer_MTU3_init();		// Timer fpr SysTick
 152                             		.loc 1 135 0
 153 0008 05 00 00 00             		bsr	_Timer_MTU3_init
 136:../src/board.c **** 	LED1_DDR = 1;
 154                             		.loc 1 136 0
 155 000c FB 5E 0C C0 08          		mov.L	#0x8c00c, r5
 156 0011 CC 54                   		mov.B	[r5], r4
 157 0013 75 34 20                		or	#32, r4
 158 0016 C3 54                   		mov.B	r4, [r5]
 137:../src/board.c **** 	LED1_Port = 1;
 159                             		.loc 1 137 0
 160 0018 FB 5E 0C C0 08          		mov.L	#0x8c00c, r5
 161 001d CD 54 20                		mov.B	32[r5], r4
 162 0020 75 34 20                		or	#32, r4
 163 0023 C7 54 20                		mov.B	r4, 32[r5]
 138:../src/board.c **** 	LED1_Port = 1;
 164                             		.loc 1 138 0
 165 0026 FB 5E 0C C0 08          		mov.L	#0x8c00c, r5
 166 002b CD 54 20                		mov.B	32[r5], r4
 167 002e 75 34 20                		or	#32, r4
 168 0031 C7 54 20                		mov.B	r4, 32[r5]
 139:../src/board.c **** 	LED2_DDR = 1;
 169                             		.loc 1 139 0
 170 0034 FB 5E 02 C0 08          		mov.L	#0x8c002, r5
 171 0039 CC 54                   		mov.B	[r5], r4
 172 003b 75 34 10                		or	#16, r4
 173 003e C3 54                   		mov.B	r4, [r5]
 140:../src/board.c **** 	LED2_Port = 1;
 174                             		.loc 1 140 0
 175 0040 FB 5E 02 C0 08          		mov.L	#0x8c002, r5
 176 0045 CD 54 20                		mov.B	32[r5], r4
 177 0048 75 34 10                		or	#16, r4
 178 004b C7 54 20                		mov.B	r4, 32[r5]
 141:../src/board.c **** 
 142:../src/board.c **** }
 179                             		.loc 1 142 0
 180 004e 3F 66 01                		rtsd	#4, r6-r6
 181                             	.LFE2:
 183                             		.section	.text.delay_ms,"ax",@progbits
 184                             		.global	_delay_ms
 186                             	_delay_ms:
 187                             	.LFB3:
 143:../src/board.c **** 
 144:../src/board.c **** 
 145:../src/board.c **** /************************************************************************
 146:../src/board.c **** *! \fn			void delay_ms(uint32_t delay_time)
 147:../src/board.c **** *  \brief		DelayRotine
 148:../src/board.c **** *  \param		none
 149:../src/board.c **** *  \exception	none
 150:../src/board.c **** *  \return		none
 151:../src/board.c **** ************************************************************************/
 152:../src/board.c **** void delay_ms(uint32_t delay_time){
 188                             		.loc 1 152 0
 189 0000 7E A6                   		push.l	r6
 190                             	.LCFI7:
 191 0002 71 06 FC                		add	#-4, r0, r6
 192                             	.LCFI8:
 193 0005 EF 60                   		mov.L	r6, r0
 194                             	.LCFI9:
 195 0007 E3 61                   		mov.L	r1, [r6]
 153:../src/board.c **** 
 154:../src/board.c **** 	delay_counter = delay_time;
 196                             		.loc 1 154 0
 197 0009 FB 52 00 00 00 00       		mov.L	#_delay_counter, r5
 198 000f EC 64                   		mov.L	[r6], r4
 199 0011 E3 54                   		mov.L	r4, [r5]
 155:../src/board.c **** 	while(delay_counter){
 200                             		.loc 1 155 0
 201 0013 2E 03                   		bra	.L7
 202                             	.L8:
 156:../src/board.c **** 		asm("nop");
 203                             		.loc 1 156 0
 204                             	 ; 156 "../src/board.c" 1
 205 0015 03                      		nop
 206                             	 ; 0 "" 2
 207                             	.L7:
 155:../src/board.c **** 	while(delay_counter){
 208                             		.loc 1 155 0 discriminator 1
 209 0016 FB 52 00 00 00 00       		mov.L	#_delay_counter, r5
 210 001c EC 55                   		mov.L	[r5], r5
 211 001e 61 05                   		cmp	#0, r5
 212 0020 21 F5                   		bne	.L8
 157:../src/board.c **** 	}
 158:../src/board.c **** 
 159:../src/board.c **** }
 213                             		.loc 1 159 0
 214 0022 3F 66 02                		rtsd	#8, r6-r6
 215                             	.LFE3:
 217                             		.section	.text.SysTick_Handler,"ax",@progbits
 218                             		.global	_SysTick_Handler
 220                             	_SysTick_Handler:
 221                             	.LFB4:
 160:../src/board.c **** 
 161:../src/board.c **** /************************************************************************
 162:../src/board.c **** *! \fn			void SysTick_Handler (void)
 163:../src/board.c **** *  \brief		System Tick Interrupt Service Routine
 164:../src/board.c **** *  \param		none
 165:../src/board.c **** *  \exception	none
 166:../src/board.c **** *  \return		none
 167:../src/board.c **** ************************************************************************/
 168:../src/board.c **** void SysTick_Handler (void){
 222                             		.loc 1 168 0
 223 0000 7E A6                   		push.l	r6
 224                             	.LCFI10:
 225 0002 EF 06                   		mov.L	r0, r6
 226                             	.LCFI11:
 169:../src/board.c **** 
 170:../src/board.c ****     ms_counter++;
 227                             		.loc 1 170 0
 228 0004 FB 52 00 00 00 00       		mov.L	#_ms_counter, r5
 229 000a EC 55                   		mov.L	[r5], r5
 230 000c 71 54 01                		add	#1, r5, r4
 231 000f FB 52 00 00 00 00       		mov.L	#_ms_counter, r5
 232 0015 E3 54                   		mov.L	r4, [r5]
 171:../src/board.c **** 	ms_counter2++;
 233                             		.loc 1 171 0
 234 0017 FB 52 00 00 00 00       		mov.L	#_ms_counter2, r5
 235 001d EC 55                   		mov.L	[r5], r5
 236 001f 71 54 01                		add	#1, r5, r4
 237 0022 FB 52 00 00 00 00       		mov.L	#_ms_counter2, r5
 238 0028 E3 54                   		mov.L	r4, [r5]
 172:../src/board.c **** 	if(delay_counter)
 239                             		.loc 1 172 0
 240 002a FB 52 00 00 00 00       		mov.L	#_delay_counter, r5
 241 0030 EC 55                   		mov.L	[r5], r5
 242 0032 61 05                   		cmp	#0, r5
 243 0034 20 15                   		beq	.L9
 173:../src/board.c **** 		delay_counter--;
 244                             		.loc 1 173 0
 245 0036 FB 52 00 00 00 00       		mov.L	#_delay_counter, r5
 246 003c EC 55                   		mov.L	[r5], r5
 247 003e 71 54 FF                		add	#-1, r5, r4
 248 0041 FB 52 00 00 00 00       		mov.L	#_delay_counter, r5
 249 0047 E3 54                   		mov.L	r4, [r5]
 250                             	.L9:
 174:../src/board.c **** 
 175:../src/board.c **** 
 176:../src/board.c **** //       NVIC_ClearPendingIRQ(SysTick_IRQn);
 177:../src/board.c **** }
 251                             		.loc 1 177 0
 252 0049 3F 66 01                		rtsd	#4, r6-r6
 253                             	.LFE4:
 255                             		.section	.text.init_IO,"ax",@progbits
 256                             		.global	_init_IO
 258                             	_init_IO:
 259                             	.LFB5:
 178:../src/board.c **** 
 179:../src/board.c **** /************************************************************************
 180:../src/board.c **** *! \fn			void init_IO(void)
 181:../src/board.c **** *  \brief		Init IOP
 182:../src/board.c **** *
 183:../src/board.c **** *  \param		none
 184:../src/board.c **** *  \exception	none
 185:../src/board.c **** *  \return		none
 186:../src/board.c **** ************************************************************************/
 187:../src/board.c **** void init_IO(void){
 260                             		.loc 1 187 0
 261 0000 7E A6                   		push.l	r6
 262                             	.LCFI12:
 263 0002 EF 06                   		mov.L	r0, r6
 264                             	.LCFI13:
 188:../src/board.c **** 
 189:../src/board.c **** 	PORT2.PDR.BIT.B2=1;		// Freigaben für PD und SS
 265                             		.loc 1 189 0
 266 0004 FB 5E 02 C0 08          		mov.L	#0x8c002, r5
 267 0009 CC 54                   		mov.B	[r5], r4
 268 000b 65 44                   		or	#4, r4
 269 000d C3 54                   		mov.B	r4, [r5]
 190:../src/board.c **** 	PORT3.PDR.BIT.B3=1;
 270                             		.loc 1 190 0
 271 000f FB 5E 03 C0 08          		mov.L	#0x8c003, r5
 272 0014 CC 54                   		mov.B	[r5], r4
 273 0016 65 84                   		or	#8, r4
 274 0018 C3 54                   		mov.B	r4, [r5]
 191:../src/board.c **** }
 275                             		.loc 1 191 0
 276 001a 3F 66 01                		rtsd	#4, r6-r6
 277                             	.LFE5:
 415                             	.Letext0:
 416                             		.file 2 "C:/projekte/Repo/PowerBoard/Firmware_e2/Powerboard/generate/iodefine.h"
 417                             		.file 3 "C:\\Program Files (x86)\\GCC for Renesas RX 4.8.4.201803-GNURX-ELF\\rx-elf\\rx-elf\\/rx-e
